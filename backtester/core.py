# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12wPKok2NNh7jLtSfbd_7nwGC4Pzkh1zH
"""
from datetime import datetime, timedelta
from scipy.ndimage import shift
import matplotlib.pyplot as plt
import scipy.stats as stats
from datetime import date
from scipy.optimize import minimize
import cupy as np
import os
import joblib
import seaborn as sns
import numpy as np2
import pandas as pd
import matplotlib
import random
import time
import math
import warnings

# Let's write a function that returns a set of upper
#     and lower bounds + a set of all bounds

def range_prices(pa_t,pb_t,N_t):

    i_Bi = np.arange(N_t)
    bs_Bi = np.arange(pb_t, pa_t, - (pb_t - pa_t) / N_t)
    as_Bi = shift(bs_Bi.get(), - 1, cval = pa_t)
    pr_ranges = np.append(pb_t, as_Bi)

    return bs_Bi, as_Bi, pr_ranges

# since the set of prices is known, for a GIVEN tau, let us determine the prices-instants of time at which -
# - the reference bucket Z(s) is redefined.
# The moment of final zeroing after T final liquidity reset is not included in the set returned by the function

def z_list_t(tau, prices_c, mu_bucket, ind_in_):

    z_list = []
    for i in range(len(prices_c)):
        if i == 0:
            z_list.append(i)
            z_ = i
        else:
            if abs(ind_in_[i] - ind_in_[z_]) > tau:
                z_list.append(i)
                z_ = i
    z_list = np.asarray(z_list)

    return z_list

def x_Nd(_tau, _mu_bucket, pr0, range_prices_ex, a):

    x_ind_Z = np.digitize(pr0, range_prices_ex[2], right = True) - 1# номер бакета каждой цены аллокации (без краевых бакетов)
    xi_ar = np.where(((np.tile(np.arange(_mu_bucket), (len(pr0),1)) > x_ind_Z.reshape(-1,1)) & (
        np.tile(np.arange(_mu_bucket), (len(pr0),1)) < x_ind_Z.reshape(-1,1) + _tau + 1)),a / (2 * _tau),
            np.where((np.tile(np.arange(_mu_bucket), (len(pr0),1)) < x_ind_Z.reshape(-1,1)) & (
                np.tile(np.arange(_mu_bucket), (len(pr0),1)) > x_ind_Z.reshape(-1,1) - _tau - 1),a / (2 * _tau),0))
    xi_ar[np.arange(len(pr0)), x_ind_Z] = 1 - np.sum(xi_ar,axis=1)

    return xi_ar

# Feature generation functions

def rolling_window_np(a, window):

    shape = a.shape[:-1] + (a.shape[-1] - window + 1, window)
    strides = a.strides + (a.strides[-1],)
    st = np2.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)

    return st

def data_transform(df, macd_1, macd_2, std_long, std_short):

    t_min = macd_1
    eth_k_min = df['close'].ewm(span = 12 * t_min, adjust = False, min_periods = 12 * t_min).mean()
    eth_d_min = df['close'].ewm(span = 26 * t_min, adjust = False, min_periods = 26 * t_min).mean()
    eth_macd_min = eth_k_min - eth_d_min
    eth_macd_s_min = eth_macd_min.ewm(span = 9 * t_min, adjust = False, min_periods = 9 * t_min).mean()
    eth_macd_h_min = eth_macd_min - eth_macd_s_min
    df['k_min'] = eth_k_min
    df['d_min'] = eth_d_min
    df['macd_min'] = eth_macd_min
    df['signal_min'] = eth_macd_s_min
    df['del_min'] = eth_macd_h_min

    t_h = macd_2
    eth_k_h = df['close'].ewm(span = 12 * t_h, adjust = False, min_periods = 12 * t_h).mean()
    eth_d_h = df['close'].ewm(span = 26 * t_h, adjust = False, min_periods = 26 * t_h).mean()
    eth_macd_h = eth_k_h - eth_d_h
    eth_macd_s_h = eth_macd_h.ewm(span = 9 * t_h, adjust = False, min_periods = 9 * t_h).mean()
    eth_macd_h_h = eth_macd_h - eth_macd_s_h

    df['k_h'] = eth_k_h
    df['d_h'] = eth_d_h
    df['macd_h'] = eth_macd_h
    df['signal_h'] = eth_macd_s_h
    df['del_h'] = eth_macd_h_h

    std_per = std_long
    df[f'std_{std_long}'] = 0
    df[f'std_{std_long}'].iloc[std_per - 1:] = np.std(rolling_window_np(df.close.values, std_per), 1)

    std_per = std_short
    df[f'std_{std_short}'] = 0
    df[f'std_{std_short}'].iloc[std_per - 1:] = np.std(rolling_window_np(df.close.values, std_per), 1)

    df['std_d'] = df[f'std_{std_short}'] - df[f'std_{std_long}']

    df = df.iloc[(26 + 9) * t_h - 2:,:]

    return df

def find_nearest_d(array, value):

    idx = (np2.abs(array - value)).argmin()

    return array[idx], idx

def V_init_max(mu_bucket, pa_Bi, pb_Bi):

    V_Bi = np.zeros((mu_bucket + 2, 6)) # 2D matrix with the number of buckets+2 to represent prices above/below the range
    V_Bi[:,5] = np.arange(mu_bucket + 2) # Let's number the buckets. 0th and last hypothetical
    V_Bi[1:-1,4] = np.asarray(pa_Bi) # upper limit of the bucket
    V_Bi[1:-1,3] = np.asarray(pb_Bi) # lower limit of the bucket
    V_Bi[1:-1,2] = 0 # fixed liquidity

    return V_Bi

def V_2d_max(price, range_prices_, V_m, L_cur):

    ind_in_ = np.digitize(price, range_prices_, right = True)#.item()

    V_m[1:ind_in_, 1] = 0
    V_m[1:ind_in_, 0] = 1 / np.sqrt(V_m[1:ind_in_, 4]) - 1 / np.sqrt(V_m[1:ind_in_,3])

    V_m[ind_in_ + 1:-1, 1] = np.sqrt(V_m[ind_in_ + 1:-1,3]) - np.sqrt(V_m[ind_in_ + 1:-1,4])
    V_m[ind_in_ + 1:-1, 0] = 0

    sqrt_price = np.sqrt(price)
    V_m[ind_in_, 1] = sqrt_price - np.sqrt(V_m[ind_in_,4])
    V_m[ind_in_, 0] = 1 / sqrt_price - 1/ np.sqrt(V_m[ind_in_,3])

    V_m[1:-1,2] = L_cur
    V_m[:,:2] *= V_m[:, 2, np.newaxis]

    return V_m


def V_3d_max(prices, ind_in_func, V_m, L_cur, _gamma):

    ind_in = ind_in_func
    V_Bi2_0 = np.tile(V_m, (len(ind_in), 1, 1))

    n_V = L_cur.shape[0]
    chunk_size = chunk_size_t

    result_shape = (n_V, V_Bi2_0.shape[0], V_Bi2_0.shape[1], V_Bi2_0.shape[2])
    ret_ep_total = np.zeros(n_V)

    for i_V in range(0, n_V, chunk_size):

        chunk_slice = slice(i_V, i_V + chunk_size)
        V_Bi2_chunk = np.tile(V_Bi2_0, (chunk_size, 1, 1, 1))

        ind_up_ = V_Bi2_chunk[:, :, :, 5] < ind_in.reshape(-1, 1)
        ind_dwn_ = V_Bi2_chunk[:, :, :, 5] > ind_in.reshape(-1, 1)
        ind_in_ = V_Bi2_chunk[:, :, :, 5] == ind_in.reshape(-1, 1)

        V_Bi2_chunk[:, :, :, 1][ind_up_] = 0
        V_Bi2_chunk[:, :, :, 0][ind_up_] = (
            1 / np.sqrt(V_Bi2_chunk[:, :, :, 4][ind_up_]) -
            1 / np.sqrt(V_Bi2_chunk[:, :, :, 3][ind_up_]))

        V_Bi2_chunk[:, :, :, 1][ind_dwn_] = (
            np.sqrt(V_Bi2_chunk[:, :, :, 3][ind_dwn_]) -
            np.sqrt(V_Bi2_chunk[:, :, :, 4][ind_dwn_]))
        V_Bi2_chunk[:, :, :, 0][ind_dwn_] = 0

        V_Bi2_chunk[:, :, :, 1][ind_in_] = (
            np.tile(np.sqrt(prices), chunk_size) -
            np.sqrt(V_Bi2_chunk[:, :, :, 4][ind_in_]))
        V_Bi2_chunk[:, :, :, 0][ind_in_] = (
            1 / np.tile(np.sqrt(prices), chunk_size) -
            1 / np.sqrt(V_Bi2_chunk[:, :, :, 3][ind_in_]))

        V_Bi2_chunk[:, :, 1:-1, 2] = np.repeat(
            L_cur[chunk_slice, np.newaxis, :], prices.shape[0], axis=1)

        np.multiply(
            V_Bi2_chunk[:, :, :, :2],
            V_Bi2_chunk[:, :, :, 2:3],
            out=V_Bi2_chunk[:, :, :, :2])

        ret_ep = np.diff(V_Bi2_chunk[:, :, 1:-1, :2], axis=1)
        ret_ep = np.maximum(ret_ep, 0)

        ret_ep[:,:,:,0] *= prices[-1]
        ret_ep = np.sum(ret_ep, axis=(1, 2, 3)) * _gamma

        ret_ep_total[chunk_slice] = ret_ep

        # del V_Bi2_chunk
        # np.get_default_memory_pool().free_all_blocks()

    return ret_ep_total

def V_3d_max_LP(prices, ind_in_func, V_m, L_cur, Li_ep_LP, _gamma, TYPE_M = 0, DYN_W = False):

    ind_in = ind_in_func
    V_Bi2_0 = np.tile(V_m, (len(ind_in), 1, 1))

    n_V = L_cur.shape[0]
    chunk_size = n_V

    ratio_L = np.where(Li_ep_LP > L_cur, 1, Li_ep_LP / L_cur) # end14-03
    ratio_Lw = Li_ep_LP / L_cur
    result_shape = (n_V, V_Bi2_0.shape[0], V_Bi2_0.shape[1], V_Bi2_0.shape[2])

    for i_V in range(0, n_V, chunk_size):

        chunk_slice = slice(i_V, i_V + chunk_size)
        V_Bi2_chunk = np.tile(V_Bi2_0, (chunk_size, 1, 1, 1))

        ind_up_ = V_Bi2_chunk[:, :, :, 5] < ind_in.reshape(-1, 1)
        ind_dwn_ = V_Bi2_chunk[:, :, :, 5] > ind_in.reshape(-1, 1)
        ind_in_ = V_Bi2_chunk[:, :, :, 5] == ind_in.reshape(-1, 1)

        V_Bi2_chunk[:, :, :, 1][ind_up_] = 0
        V_Bi2_chunk[:, :, :, 0][ind_up_] = (
            1 / np.sqrt(V_Bi2_chunk[:, :, :, 4][ind_up_]) -
            1 / np.sqrt(V_Bi2_chunk[:, :, :, 3][ind_up_]))

        V_Bi2_chunk[:, :, :, 1][ind_dwn_] = (
            np.sqrt(V_Bi2_chunk[:, :, :, 3][ind_dwn_]) -
            np.sqrt(V_Bi2_chunk[:, :, :, 4][ind_dwn_]))
        V_Bi2_chunk[:, :, :, 0][ind_dwn_] = 0

        V_Bi2_chunk[:, :, :, 1][ind_in_] = (
            np.tile(np.sqrt(prices), chunk_size) -
            np.sqrt(V_Bi2_chunk[:, :, :, 4][ind_in_]))
        V_Bi2_chunk[:, :, :, 0][ind_in_] = (
            1 / np.tile(np.sqrt(prices), chunk_size) -
            1 / np.sqrt(V_Bi2_chunk[:, :, :, 3][ind_in_]))

        V_Bi2_chunk[:, :, 1:-1, 2] = np.repeat(
            L_cur[chunk_slice, np.newaxis, :], prices.shape[0], axis=1)

        np.multiply(
            V_Bi2_chunk[:, :, :, :2],
            V_Bi2_chunk[:, :, :, 2:3],
            out=V_Bi2_chunk[:, :, :, :2])

        ret_ep = V_Bi2_chunk[:, :, 1:-1, :2].copy()
        ret_ep[:,:,:,0] *= prices[-1]

        if DYN_W and TYPE_M == 0:
            w_ep = ret_ep.copy()
            w_LP_ep = np.sum(ratio_Lw * np.sum(w_ep[0,-1,:,:], axis = 1), axis = 1)
        elif DYN_W and TYPE_M == 1:
            w_ep = ret_ep.copy()
            w_ep = np.sum(w_ep[:,-1,:,:].reshape(n_rg, 2), axis=1, keepdims=True)
            w_LP_ep = np.sum(ratio_Lw * w_ep.T, axis = 1, keepdims=True)
        else:
            w_LP_ep = 0

        ret_ep = np.diff(ret_ep, axis=1)
        ret_ep = np.maximum(ret_ep, 0)

        ret_ep = np.sum(ret_ep, axis = 1) * _gamma
        ret_ep_pool = np.sum(ret_ep)
        ret_ep = np.sum(ret_ep, axis = 2)
        ret_ep = np.sum(ratio_L * ret_ep, axis = 1)

        # del V_Bi2_chunk
        # np.get_default_memory_pool().free_all_blocks()

    return ret_ep, ret_ep_pool, w_LP_ep, ratio_Lw#, V_Bi2_chunk#, V_Bi2_0, V_Bi2_chunk, i_V

def Li_Ei_max(price_upd, W, xi_array, ind_in, V_1):

    L_ar = np.zeros(xi_array.shape)
    Wx = W * xi_array
    p_up = price_upd
    ind_up = ind_in[0] - 1
    L_ar[:,:ind_up] = Wx[:,:ind_up] / p_up * np.sqrt(V_1[:,4][1:ind_up + 1] * V_1[
        :,3][1:ind_up + 1]) / (np.sqrt(V_1[:,3][1:ind_up + 1]) - np.sqrt(V_1[:,4][1:ind_up + 1]))
    L_ar[:,ind_up:] = Wx[:,ind_up:] / (np.sqrt(V_1[:,3][ind_up + 1:-1]) - np.sqrt(
        V_1[:,4][ind_up + 1:-1]))

    if p_up != V_1[:,3][ind_up + 1]:
        x_ = (np.sqrt(V_1[:,3][ind_up + 1]) * np.sqrt(p_up)) / (np.sqrt(V_1[:,3][ind_up + 1]) - np.sqrt(p_up))
        y_ = 1/(np.sqrt(p_up) - np.sqrt(V_1[:,4][ind_up + 1]))
        L_ar[:,ind_up] = Wx[:,ind_up] / (p_up +x_ / y_) * x_

    return L_ar

# main functions
def v3_model_max(W_init, price_set, xi_array, _mu_bucket,
                 range_prices_func_0, range_prices_func_1,range_prices_func_2,
                 ind_in_func, _gamma):

    i = 0
    W_ = W_init
    V_0 = V_init_max(_mu_bucket, range_prices_func_1, range_prices_func_0)

    V_2d_ep = V_2d_max(price_set[0], range_prices_func_2, V_0, 1)
    Li_ep = Li_Ei_max(price_set[0], W_, xi_array, ind_in_func, V_2d_ep)
    V_3d_ep = V_3d_max(price_set, ind_in_func, V_0, Li_ep, _gamma)

    return V_3d_ep

def v3_model_LP_max(W_init, W_init_LP, price_set, xi_array_opt, LP_array, _mu_bucket,
                 range_prices_func_0, range_prices_func_1,range_prices_func_2,
                 ind_in_func, _gamma, TYPE_M = 0, DYN_W = False):# add one optim xi_ar pool

    i = 0
    W_ = W_init
    V_0 = V_init_max(_mu_bucket, range_prices_func_1, range_prices_func_0)
    V_2d_ep = V_2d_max(price_set[0], range_prices_func_2, V_0, 1)

    Li_ep = Li_Ei_max(price_set[0], W_, xi_array_opt, ind_in_func, V_2d_ep)
    Li_ep_LP = Li_Ei_max(price_set[0], W_init_LP, LP_array, ind_in_func, V_2d_ep)

    V_3d_ep = V_3d_max_LP(price_set, ind_in_func, V_0, Li_ep, Li_ep_LP, _gamma, TYPE_M, DYN_W)

    return V_3d_ep

def find_and_check_nearest(array, value, threshold=0.1):

    array = np.asarray(array)
    idx = np.abs(array - value).argmin()
    nearest_value = array[idx]

    is_within_threshold = abs(nearest_value / value - 1) <= threshold

    return nearest_value, idx, is_within_threshold

def generate_normalized_vectors(m, k, distribution='uniform'):

    if distribution == 'uniform':
        vectors = np.random.uniform(0, 1, (m, k+1))
    elif distribution == 'normal':
        vectors = np.random.normal(0, 1, (m, k+1))
    elif distribution == 'exponential':
        vectors = np.random.exponential(1, (m, k+1))
    else:
        raise ValueError("Unsupported distribution")

    normalized_vectors = np.maximum(vectors / vectors.sum(axis=1, keepdims=True), 1e-60)

    return normalized_vectors

def x_Nd_best(tau, mu_bucket, p0, range_prices_2, best_str):

    x_ind_Z = np.digitize(p0, range_prices_2, right = True) - 1
    xi_arange = np.tile(np.arange(mu_bucket), (best_str.shape[0], 1))
    xi_ar = np.tile(np.zeros(mu_bucket), (best_str.shape[0], 1))

    if tau != 0:
        u_r = np.where((xi_arange > x_ind_Z.reshape(-1,1)) & (xi_arange < x_ind_Z.reshape(-1,1) + tau + 1))[0]
        xi_ar[np.where((xi_arange > x_ind_Z.reshape(-1,1)) & (xi_arange < x_ind_Z.reshape(-1,1) + tau + 1))] = ratio_right_best(u_r, best_str)
        u_l = np.where((xi_arange < x_ind_Z.reshape(-1,1)) & (xi_arange > x_ind_Z.reshape(-1,1) - tau - 1))[0]
        xi_ar[np.where((xi_arange < x_ind_Z.reshape(-1,1)) & (xi_arange > x_ind_Z.reshape(-1,1) - tau - 1))] = ratio_left_best(u_l, best_str)
    xi_ar[np.where(xi_arange == x_ind_Z.reshape(-1,1))] = 1 - np.sum(xi_ar, axis = 1)

    return xi_ar, best_str

def ratio_right_best(u_, best_str):

    n_list = []
    k = 0

    for bucket_r in np.split(u_, (np.where(np.diff(u_) > 0)[0] + 1).tolist()):
        ar = best_str[k][1:len(bucket_r) + 1] / 2
        if k == 0:
            ar_T = ar
        else:
            ar_T = np.concatenate((ar_T, ar))
        k += 1

    return ar_T

def ratio_left_best(u_, best_str):

    n_list = []
    k = 0

    for bucket_l in np.split(u_, (np.where(np.diff(u_) > 0)[0] + 1).tolist()):
        ar = np.flip(best_str[k][1:len(bucket_l) + 1]) / 2
        if k == 0:
            ar_T = ar
        else:
            ar_T = np.concatenate((ar_T, ar))
        k+=1

    return ar_T

def plot_dist(tau_, str_epoch):

    x_str = np.arange(2 * tau_ + 1)
    fig, ax = plt.subplots(figsize=(20, 8))
    plt.plot(x_str.get(), str_epoch.get(), color = 'r')
    plt.bar(x_str.get(), str_epoch.get())
    plt.xticks(range(0, 2 * tau_ + 1))
    plt.xlabel("Tau buckets", fontsize = 20)
    plt.ylabel("Capital allocation strategy, USDC", fontsize = 20)

    plt.show()

def normalize_predictions(predictions):

    predictions[predictions == 0] = 1e-60
    predictions_normalized = predictions / np.sum(predictions, axis=1, keepdims=True)

    return predictions_normalized

def sliding_windows_(prices_, vols_, m_):

    assert len(prices_) == len(vols_), "Array lengths must match"

    if m_ == 2:
        prices_windows = np2.lib.stride_tricks.sliding_window_view(prices_.get(), m_)
        vol_windows = np2.lib.stride_tricks.sliding_window_view(vols_.get(), m_)
        vol_windows = vol_windows.copy()
        vol_windows[:, 0] = 0

        prices_windows = np.asarray(prices_windows)
        vol_windows = np.asarray(vol_windows)

    else:
        indices = [i_ * (m_ - 1) for i_ in range((len(prices_) - 1) // (m_ - 1))]
        indices.append(len(prices_) - (len(prices_) - indices[-1] - 1))
        prices_windows = [prices_[i_:i_ + m_].copy() for i_ in indices[:-1]]
        vol_windows = [vols_[i_:i_ + m_].copy() for i_ in indices[:-1]]

        prices_windows[-1] = prices_[indices[-1] - 1:]
        vol_windows[-1] = vols_[indices[-1] - 1:]

        for vw in vol_windows:
            vw[0] = 0

    return prices_windows, vol_windows

def V_3d_max_el(prices, ind_in_func, V_m, L_cur):

    ind_in = ind_in_func
    V_Bi2_0 = np.tile(V_m, (len(ind_in), 1, 1))
    V_Bi2 = np.tile(V_Bi2_0, (L_cur.shape[0], 1, 1, 1))

    ind_up_ = V_Bi2[:,:,:,5] < ind_in.reshape(-1,1)
    ind_dwn_ = V_Bi2[:,:,:,5] > ind_in.reshape(-1,1)
    ind_in_ = V_Bi2[:,:,:,5] == ind_in.reshape(-1,1)

    V_Bi2[:,:,:,1][ind_up_] = 0
    V_Bi2[:,:,:,0][ind_up_] = 1 / np.sqrt(V_Bi2[:,:,:,4][ind_up_]) - 1 / np.sqrt(V_Bi2[:,:,:,3][ind_up_])

    V_Bi2[:,:,:,1][ind_dwn_] = np.sqrt(V_Bi2[:,:,:,3][ind_dwn_]) - np.sqrt(V_Bi2[:,:,:,4][ind_dwn_])
    V_Bi2[:,:,:,0][ind_dwn_] = 0

    V_Bi2[:,:,:,1][ind_in_] = np.tile(np.sqrt(prices), L_cur.shape[0]) - np.sqrt(V_Bi2[:,:,:,4][ind_in_])
    V_Bi2[:,:,:,0][ind_in_] = 1 / np.tile(np.sqrt(prices), L_cur.shape[0]) - 1 / np.sqrt(V_Bi2[:,:,:,3][ind_in_])

    V_Bi2[:,:,1:-1,2] = np.repeat(L_cur[:, np.newaxis, :], prices.shape[0], axis=1)
    V_Bi2[:, :, :, :2] = (V_Bi2[:, :, :, :2] * V_Bi2[:, :, :, 2:3]).copy()

    return V_Bi2

def v3_model_max_el(W_init, price_set, xi_array, _mu_bucket,
                 range_prices_func_0, range_prices_func_1,range_prices_func_2,
                 ind_in_func, _gamma):

    i = 0
    W_ = W_init
    V_0 = V_init_max(_mu_bucket, range_prices_func_1, range_prices_func_0)

    V_2d_ep = V_2d_max(price_set[0], range_prices_func_2, V_0, 1)
    Li_ep = Li_Ei_max(price_set[0], W_, xi_array, ind_in_func, V_2d_ep)
    V_3d_ep = V_3d_max_el(price_set, ind_in_func, V_0, Li_ep)

    ret_ep = np.sum(np.maximum(V_3d_ep[:, -1, 1:-1, :2] - V_3d_ep[:, 0, 1:-1, :2], 0), axis = 1)
    ret_ep[:,0] *= price_set[-1]
    ret_ep = np.sum(ret_ep, axis = 1) * _gamma

    return ret_ep

def sliding_windows(prices_, vols_, m_):# m_ > 1!

    assert len(prices_) == len(vols_), "Длины массивов должны совпадать"

    if m_ == 2:
        prices_windows = np.lib.stride_tricks.sliding_window_view(prices_, m_)
        vol_windows = np.lib.stride_tricks.sliding_window_view(vols_, m_)
        vol_windows = vol_windows.copy()
        vol_windows[:, 0] = 0
    else:
        indices = [i_ * (m_ - 1) for i_ in range((len(prices_) - 1) // (m_ - 1))]
        indices.append(len(prices_) - (len(prices_) - indices[-1] - 1))
        prices_windows = [prices_[i_:i_ + m_].copy() for i_ in indices[:-1]]
        vol_windows = [vols_[i_:i_ + m_].copy() for i_ in indices[:-1]]

        prices_windows[-1] = prices_[indices[-1] - 1:]
        vol_windows[-1] = vols_[indices[-1] - 1:]

        for vw in vol_windows:
            vw[0] = 0

    return prices_windows, vol_windows

def x_Nd_best_pool(mu_bucket, _apprx_n, _cu_pr_ep, range_prices_2, best_str):

    x_ind_Z = np.digitize(_cu_pr_ep, range_prices_2, right = True) - 1
    xi_arange = np.tile(np.arange(mu_bucket), (best_str.shape[0], 1))
    xi_ar = np.tile(np.zeros(mu_bucket), (best_str.shape[0], 1))
    center_index = _apprx_n // 2

    u_r = np.where((xi_arange >= x_ind_Z.reshape(-1,1)) & (xi_arange <= x_ind_Z.reshape(-1,1) + center_index))
    xi_ar[u_r] = ratio_right_best_pool(u_r[0], best_str, center_index)
    u_l = np.where((xi_arange < x_ind_Z.reshape(-1,1)) & (xi_arange > x_ind_Z.reshape(-1,1) - center_index - 1))
    xi_ar[u_l] = ratio_left_best_pool(u_l[0], best_str, center_index)

    return xi_ar

def ratio_right_best_pool(u_, best_str, _center_index):

    ar_T = np.flip(best_str[:,:_center_index + 1], axis = 1).flatten()

    return ar_T

def ratio_left_best_pool(u_, best_str, _center_index):

    ar_T = np.flip(best_str[:,_center_index + 1:], axis = 1).flatten()

    return ar_T
